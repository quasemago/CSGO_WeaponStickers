static int g_menuSite[MAXPLAYERS + 1] = {0, ...};
static int g_tempSlot[MAXPLAYERS + 1] = {-1, ...};
static int g_tempMaxSlots[MAXPLAYERS + 1] = {0, ...};
static int g_tempIndex[MAXPLAYERS + 1] = {-1, ...};
static char g_tempSearch[MAXPLAYERS +1][MAX_LENGTH_CLASSNAME];

#define ALL_SLOTS 99

void MenusClientDisconnect(int client)
{
	g_menuSite[client] = 0;
	g_tempSlot[client] = -1;
	g_tempMaxSlots[client] = 0;
	g_tempIndex[client] = -1;
	g_tempSearch[client][0] = '\0';
}

/**
 * Menus.
 */
void ShowWeaponStickersMenu(int client, const char[] search = "")
{
	if (!IsPlayerAlive(client))
	{
		CPrintToChat(client, "%t", "Need Alive");
		return;
	}

	int weapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
	if (!IsValidEntity(weapon) || !IsValidWeaponToChange(client, GetWeaponDefIndex(weapon), false))
	{
		CPrintToChat(client, "%t", "Invalid Stickers Weapon");
		return;
	}

	int slots = GetWeaponSupportedStickerSlots(weapon);
	if (slots <= 0)
	{
		CPrintToChat(client, "%t", "Invalid Stickers Weapon");
		return;
	}

	int index = eItems_GetWeaponNumByWeapon(weapon);
	if (index < 0)
	{
		CPrintToChat(client, "%t", "Validate Error");
		return;
	}

	g_tempIndex[client] = index;
	g_tempMaxSlots[client] = slots;
	strcopy(g_tempSearch[client], MAX_LENGTH_CLASSNAME, search);

	Menu menu = new Menu(MenuHandler_Menu_WeaponStickers);
	menu.SetTitle("%T", "Menu Stickers Title", client);
	
	for (int i = 0; i < slots; i++)
	{
		static char slot[16];
		IntToString(i, slot, sizeof(slot));
		
		if (g_PlayerWeapon[client][index].m_stickerDefIndex[i] != 0)
		{
			static char displayName[MAX_LENGTH_DISPLAY];
			eItems_GetStickerDisplayNameByDefIndex(g_PlayerWeapon[client][index].m_stickerDefIndex[i], displayName, sizeof(displayName));
			AddMenuItemEx(menu, slot, _, "Slot %i\n  -> %s.", i, displayName);
		}
		else
		{
			AddMenuItemEx(menu, slot, _, "Slot %i\n  -> %T.", i, "None Sticker", client);
		}
	}

	menu.AddItem("x", "", ITEMDRAW_SPACER);
	AddMenuItemEx(menu, "99", _, "%T.", "All Slots", client);

	menu.ExitButton = true;
	menu.Display(client, MENU_TIME_FOREVER);
}


public int MenuHandler_Menu_WeaponStickers(Menu menu, MenuAction action, int client, int param)
{
	if (action == MenuAction_Select)
	{
		if (g_tempIndex[client] < 0)
		{
			ShowWeaponStickersMenu(client);
			return;
		}
		
		char buffer[16];
		menu.GetItem(param, buffer, sizeof(buffer));

		g_tempSlot[client] = StringToInt(buffer);

		if (strlen(g_tempSearch[client]) > 2)
		{
			ShowWeaponStickersSetMenu(client, g_tempSlot[client], -1, g_tempSearch[client]);
		}
		else
		{
			ShowWeaponStickerSlotMenu(client, g_tempSlot[client]);
		}
	}
	else if (action == MenuAction_Cancel)
	{
		ResetClientTempVars(client);
	}
	else if (action == MenuAction_End)
	{
		delete menu;
	}
}

static void ShowWeaponStickerSlotMenu(int client, int slot)
{
	if (!IsPlayerAlive(client))
	{
		CPrintToChat(client, "%t", "Need Alive");
		return;
	}

	int weapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
	if (!eItems_IsValidWeapon(weapon))
	{
		CPrintToChat(client, "%t", "Invalid Stickers Weapon");
		return;
	}

	int weaponIndex = eItems_GetWeaponNumByWeapon(weapon);
	if (weaponIndex < 0 || weaponIndex != g_tempIndex[client])
	{
		CPrintToChat(client, "%t", "Validate Error");
		return;
	}

	Menu menu = new Menu(MenuHandler_Menu_StickerSlot);

	char weaponName[MAX_LENGTH_DISPLAY];
	eItems_GetWeaponDisplayNameByWeaponNum(weaponIndex, weaponName, sizeof(weaponName));

	if (slot != ALL_SLOTS && g_PlayerWeapon[client][weaponIndex].m_stickerDefIndex[slot] != 0)
	{
		char stickerName[MAX_LENGTH_DISPLAY];
		eItems_GetStickerDisplayNameByDefIndex(g_PlayerWeapon[client][weaponIndex].m_stickerDefIndex[slot], stickerName, sizeof(stickerName));
		menu.SetTitle("%T", "Menu Stickers Slot Already Title", client, weaponName, slot, stickerName);
	}
	else
	{
		menu.SetTitle("%T", slot == ALL_SLOTS ? "Menu Stickers Slot Title AllSlots" : "Menu Stickers Slot Title", client, weaponName, slot);
	}

	AddMenuItemEx(menu, "-1", _, "%T", "Menu Stickers Slot Remove", client);

	for (int i = 0; i < g_stickerSetsCount; i++)
	{
		static char index[16];
		IntToString(i, index, sizeof(index));

		static char displayName[MAX_LENGTH_DISPLAY];
		eItems_GetStickerSetDisplayNameByStickerSetNum(i, displayName, sizeof(displayName));

		AddMenuItemEx(menu, index, _, displayName);
	}

	menu.ExitButton = true;
	menu.ExitBackButton = true;
	menu.DisplayAt(client, g_menuSite[client], MENU_TIME_FOREVER);
}

public int MenuHandler_Menu_StickerSlot(Menu menu, MenuAction action, int client, int param)
{
	if (action == MenuAction_Select)
	{
		if (g_tempIndex[client] < 0)
		{
			ShowWeaponStickersMenu(client);
			return;
		}

		char buffer[32];
		menu.GetItem(param, buffer, sizeof(buffer));

		int setIndex = StringToInt(buffer);
		if (setIndex == -1)
		{
			if (g_tempSlot[client] == ALL_SLOTS)
			{
				for (int i = 0; i < g_tempMaxSlots[client]; i++)
				{
					g_PlayerWeapon[client][g_tempIndex[client]].m_stickerDefIndex[i] = 0;
					UpdateClientStickers(client, g_tempIndex[client], i);
				}
			}
			else
			{
				g_PlayerWeapon[client][g_tempIndex[client]].m_stickerDefIndex[g_tempSlot[client]] = 0;
				UpdateClientStickers(client, g_tempIndex[client], g_tempSlot[client]);
			}

			g_isStickerRefresh[client] = true;
			RefreshClientWeapon(client, g_tempIndex[client]);

			// Announce.
			char displayName[MAX_LENGTH_DISPLAY];
			eItems_GetWeaponDisplayNameByWeaponNum(g_tempIndex[client], displayName, sizeof(displayName));

			if (g_tempSlot[client] == ALL_SLOTS)
			{
				CPrintToChat(client, "%t", "Remove Sticker AllSlots", displayName);
			}
			else
			{
				CPrintToChat(client, "%t", "Remove Sticker", displayName, g_tempSlot[client]);
			}

			// Reopen menu.
			g_menuSite[client] = GetMenuSelectionPosition();
			ShowWeaponStickerSlotMenu(client, g_tempSlot[client]);
		}
		else
		{
			ShowWeaponStickersSetMenu(client, g_tempSlot[client], setIndex);
		}
	}
	else if (action == MenuAction_Cancel)
	{
		ResetClientTempVars(client);

		if (param == MenuCancel_ExitBack)
		{
			ShowWeaponStickersMenu(client);
		}
	}
	else if (action == MenuAction_End)
	{
		delete menu;
	}
}

static void ShowWeaponStickersSetMenu(int client, int slot, int stickerSet, const char[] search = "")
{
	if (!IsPlayerAlive(client))
	{
		CPrintToChat(client, "%t", "Need Alive");
		return;
	}

	int weapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
	if (!eItems_IsValidWeapon(weapon))
	{
		CPrintToChat(client, "%t", "Invalid Stickers Weapon");
		return;
	}

	int weaponIndex = eItems_GetWeaponNumByWeapon(weapon);
	if (weaponIndex < 0 || weaponIndex != g_tempIndex[client])
	{
		CPrintToChat(client, "%t", "Validate Error");
		return;
	}

	if (strlen(search) < 2 && stickerSet < 0)
	{
		CPrintToChat(client, "%t", "Validate Error");
		return;
	}

	Menu menu = new Menu(MenuHandler_Menu_StickerSet);
	int count;

	char weaponName[MAX_LENGTH_DISPLAY];
	eItems_GetWeaponDisplayNameByWeaponNum(weaponIndex, weaponName, sizeof(weaponName));

	// Add stickers to menu.
	if (strlen(search) > 2)
	{
		if (slot != ALL_SLOTS && g_PlayerWeapon[client][weaponIndex].m_stickerDefIndex[slot] != 0)
		{
			char displayName[MAX_LENGTH_DISPLAY];
			eItems_GetStickerDisplayNameByDefIndex(g_PlayerWeapon[client][weaponIndex].m_stickerDefIndex[slot], displayName, sizeof(displayName));
			menu.SetTitle("%T", "Menu Stickers Set Search Already Title", client, weaponName, slot, displayName, search);
		}
		else
		{
			menu.SetTitle("%T", slot == ALL_SLOTS ? "Menu Stickers Set Search Title AllSlots" : "Menu Stickers Set Search Title", client, weaponName, slot, search);
		}

		for (int i = 0; i < g_stickerCount; i++)
		{
			static char displayName[MAX_LENGTH_DISPLAY];
			eItems_GetStickerDisplayNameByStickerNum(i, displayName, sizeof(displayName));

			if (StrContains(displayName, search, false) == -1)
			{
				continue;
			}

			count++;

			static char index[16];
			IntToString(i, index, sizeof(index));
			menu.AddItem(index, displayName);
		}
	}
	else
	{
		char stickerSetName[MAX_LENGTH_DISPLAY];
		eItems_GetStickerSetDisplayNameByStickerSetNum(stickerSet, stickerSetName, sizeof(stickerSetName));

		if (slot != ALL_SLOTS && g_PlayerWeapon[client][weaponIndex].m_stickerDefIndex[slot] != 0)
		{
			char stickerName[MAX_LENGTH_DISPLAY];
			eItems_GetStickerDisplayNameByDefIndex(g_PlayerWeapon[client][weaponIndex].m_stickerDefIndex[slot], stickerName, sizeof(stickerName));
			menu.SetTitle("%T", "Menu Stickers Set Already Title", client, weaponName, slot, stickerName, stickerSetName);
		}
		else
		{
			menu.SetTitle("%T", slot == ALL_SLOTS ? "Menu Stickers Set Title AllSlots" : "Menu Stickers Set Title", client, weaponName, slot, stickerSetName);
		}

		int length = g_StickerSet[stickerSet].Length;
		for (int i = 0; i < length; i++)
		{
			int stickerNum = g_StickerSet[stickerSet].Get(i);
			if (stickerNum < 0)
			{
				continue;
			}

			static char index[16];
			IntToString(stickerNum, index, sizeof(index));

			static char displayName[MAX_LENGTH_DISPLAY];
			eItems_GetStickerDisplayNameByStickerNum(stickerNum, displayName, sizeof(displayName));

			menu.AddItem(index, displayName);
		}
	}

	if (!count && strlen(search) > 2)
	{
		AddMenuItemEx(menu, "-1", ITEMDRAW_DISABLED, "%T", "Menu Stickers Slot Search None", client);
	}

	menu.ExitButton = true;
	menu.ExitBackButton = true;
	menu.DisplayAt(client, g_menuSite[client], MENU_TIME_FOREVER);
}

public int MenuHandler_Menu_StickerSet(Menu menu, MenuAction action, int client, int param)
{
	if (action == MenuAction_Select)
	{
		if (g_tempIndex[client] < 0)
		{
			ShowWeaponStickersMenu(client);
			return;
		}

		char buffer[32];
		menu.GetItem(param, buffer, sizeof(buffer));

		int stickerNum = StringToInt(buffer);
		if (stickerNum < 0)
		{
			ShowWeaponStickersMenu(client);
			return;
		}

		int stickerSet = GetStickerSetNumByStickerNum(stickerNum);
		if (stickerSet < 0)
		{
			ShowWeaponStickersMenu(client);
			return;
		}

		// Reuse countdown.
		int time = GetTime();
		if (g_playerReuseTime[client] > time)
		{
			CPrintToChat(client, "%t", "Delay Sticker", g_playerReuseTime[client] - time);

			// Reopen menu.
			g_menuSite[client] = GetMenuSelectionPosition();
			ShowWeaponStickersSetMenu(client, g_tempSlot[client], stickerSet, g_tempSearch[client]);
			return;
		}

		int stickerDefIndex = eItems_GetStickerDefIndexByStickerNum(stickerNum);
		if (g_tempSlot[client] == ALL_SLOTS)
		{
			for (int i = 0; i < g_tempMaxSlots[client]; i++)
			{
				g_PlayerWeapon[client][g_tempIndex[client]].m_stickerDefIndex[i] = stickerDefIndex;
				UpdateClientStickers(client, g_tempIndex[client], i);
			}
		}
		else
		{
			g_PlayerWeapon[client][g_tempIndex[client]].m_stickerDefIndex[g_tempSlot[client]] = stickerDefIndex;
			UpdateClientStickers(client, g_tempIndex[client], g_tempSlot[client]);
		}

		g_isStickerRefresh[client] = true;
		RefreshClientWeapon(client, g_tempIndex[client]);

		// Announce.
		char stickerName[MAX_LENGTH_DISPLAY];
		char weaponName[MAX_LENGTH_DISPLAY];
		eItems_GetWeaponDisplayNameByWeaponNum(g_tempIndex[client], weaponName, sizeof(weaponName));
		eItems_GetStickerDisplayNameByStickerNum(stickerNum, stickerName, sizeof(stickerName));

		if (g_tempSlot[client] == ALL_SLOTS)
		{
			CPrintToChat(client, "%t", "Change Sticker AllSlots", stickerName, weaponName);
		}
		else
		{
			CPrintToChat(client, "%t", "Change Sticker", stickerName, weaponName, g_tempSlot[client]);
		}

		// Reopen menu.
		g_menuSite[client] = GetMenuSelectionPosition();
		ShowWeaponStickersSetMenu(client, g_tempSlot[client], stickerSet, g_tempSearch[client]);
	}
	else if (action == MenuAction_Cancel)
	{
		if (param == MenuCancel_ExitBack)
		{
			if (strlen(g_tempSearch[client]) > 2)
			{
				ResetClientTempVars(client);
				ShowWeaponStickersMenu(client);
			}
			else
			{
				ShowWeaponStickerSlotMenu(client, g_tempSlot[client]);
			}
		}
	}
	else if (action == MenuAction_End)
	{
		delete menu;
	}
}

static void ResetClientTempVars(int client)
{
	g_menuSite[client] = 0;
	g_tempSlot[client] = -1;
	g_tempMaxSlots[client] = 0;
	g_tempIndex[client] = -1;
	g_tempSearch[client][0] = '\0';
}